#' Separate a big `skim_df` into smaller data frames, by type.
#'
#' The data frames produced by [skim()] are wide and sparse, filled with
#' columns that are mostly `NA`. For that reason, it can be convenient to
#' work with "by type" subsets of the original data frame. These smaller
#' subsets have their `NA` columns removed.
#'
#' `partition()` creates a list of smaller `skim_df` data frames. Each entry
#' in the list is a data type from the original `skim_df`. The inverse of
#' `partition()` is `bind()`, which takes the list and produces the original
#' `skim_df`. While `partition()` keeps all of the subtables as list entries,
#' `yank()` gives you a single subtable for a data type.
#'
#' @param data A `skim_df`.
#' @param skim_type A character scalar. The subtable to extract from a `skim_df`.
#' @return A `skim_list` of `skim_df`'s, by type.
#' @examples
#' # Create a wide skimmed data frame (a skim_df)
#' skimmed <- skim(iris)
#'
#' # Separate into a list of subtables by type
#' separate <- partition(skimmed)
#'
#' # Put back together
#' identical(bind(separate), skimmed)
#' # > TRUE
#'
#' # Alternatively, get the subtable of a particular type
#' yank(skimmed, "factor")
#' @export
partition <- function(data) {
  assert_is_skim_df(data)
  data_as_list <- split(data, data$skim_type)
  types <- names(data_as_list)
  groups <- attr(data, "groups")

  skimmers <- reconcile_skimmers(data, groups)
  reduced <- purrr::imap(data_as_list, simplify_skimdf, skimmers, groups)

  reassign_skim_attrs(
    reduced,
    data,
    class = "skim_list",
    skimmers_used = skimmers
  )
}

#' Align the skimmers_used attribute with the current columns in the data
#'
#' This catches the case where users partition (or more likely print) a data
#' frame that has had columns added after skimming.
#' @noRd
reconcile_skimmers <- function(data, groups) {
  all_columns <- names(data)
  skimmers_used <- attr(data, "skimmers_used")
  with_base_columns <- c(
    "skim_variable", "skim_type", collapse_skimmers(skimmers_used)
  )
  extra_cols <- dplyr::setdiff(all_columns, with_base_columns)
  if (length(extra_cols) > 0) {
    grouped <- dplyr::group_by(data, !!rlang::sym("skim_type"))
    complete_by_type <- dplyr::summarize_at(
      grouped,
      dplyr::vars(extra_cols),
      ~ !all(is.na(.x))
    )
    complete_cols <- purrr::pmap(
      complete_by_type,
      get_complete_columns,
      names = extra_cols
    )
    new_cols_by_type <- rlang::set_names(
      complete_cols,
      complete_by_type$skim_type
    )
    skimmers_used <- purrr::list_merge(skimmers_used, !!!new_cols_by_type)
  }

  skimmers_used
}

collapse_skimmers <- function(skimmers_used) {
  with_type <- purrr::imap(skimmers_used, ~ paste(.y, .x, sep = "."))
  purrr::flatten_chr(with_type)
}

get_complete_columns <- function(skim_type, ..., names) {
  names[c(...)]
}

#' For each type subtable, only select columns generated by this type's skimmers
#' This function also catches the case where the user removed columns from
#' the skim_df
#' @noRd
simplify_skimdf <- function(data, skim_type, skimmers, groups) {
  stopifnot(has_variable_column(data))
  names(data) <- stringr::str_remove(names(data), paste0(skim_type, "\\."))
  keep <- c("skim_variable", groups, skimmers[[skim_type]])
  cols_in_data <- names(data)
  out <- dplyr::select(data, !!!dplyr::intersect(keep, cols_in_data))

  structure(
    out,
    class = c("one_skim_df", "tbl_df", "tbl", "data.frame"),
    skim_type = skim_type
  )
}

#' @describeIn partition The inverse of a `partition()`. Rebuild the original
#'   `skim_df`.
#' @export
bind <- function(data) {
  assert_is_skim_list(data)
  with_namespaces <- purrr::imap(data, add_namespaces)
  combined <- dplyr::bind_rows(!!!with_namespaces, .id = "skim_type")
  reassign_skim_attrs(combined, data)
}

add_namespaces <- function(data, skim_type) {
  meta_columns <- c("skim_variable", dplyr::group_vars(data))
  no_meta_columns <- dplyr::setdiff(names(data), meta_columns)
  with_namespace <- paste(skim_type, no_meta_columns, sep = ".")
  rlang::set_names(data, c(meta_columns, with_namespace))
}

#' @describeIn partition Extract a subtable from a `skim_df` with a particular
#'   type.
#' @export
yank <- function(data, skim_type) {
  partition(data)[[skim_type]]
}

#' Only show a subset of summary statistics after skimming
#'
#' This function is a variant of [dplyr::select()] designed to work with
#' `skim_df` objects. When using `focus()`, `skimr` metadata columns are kept,
#' and `skimr` print methods are still utilized. Otherwise, the signature and
#' behavior is identical to [dplyr::select()].
#'
#' @param .data A `skim_df` object.
#' @inheritParams dplyr::select
#' @examples
#' # Compare
#' iris %>%
#'   skim() %>%
#'   dplyr::select(numeric.missing)
#'
#' iris %>%
#'   skim() %>%
#'   focus(numeric.missing)
#'
#' # This is equivalent to
#' iris %>%
#'   skim() %>%
#'   dplyr::select(skim_variable, skim_type, numeric.missing)
#' @export
focus <- function(.data, ...) {
  assert_is_skim_df(.data)
  reduced <- dplyr::select(.data, "skim_type", "skim_variable", ...)
  if (could_be_skim_df(reduced)) {
    reassign_skim_attrs(reduced, .data)
  } else {
    stop("Cannot drop 'skim_variable' or 'skim_type' columns")
  }
}

#' Skim results returned as a tidy long data frame with four columns:
#' variable, type, stat and formatted.
#' @param .data A tibble, or an object that can be coerced into a tibble.
#' @param ...  Columns to select for skimming. When none are provided, the
#'   default is to skim all columns.
#' @return A `skim_df` object, which also inherits the class(es) of the input
#'   data. The result is usually a data frame or tibble.
#' @examples
#' to_long(iris)
#' @export
to_long <- function(.data, ...) {
  skimmed <- skim(.data, ...)
  tidyr::gather(
    skimmed,
    key = "stat",
    value = "formatted",
    na.rm = TRUE,
    -!!rlang::sym("skim_type"),
    -!!rlang::sym("skim_variable")
  )
}

#' Deprecated functions from skimr v1
#'
#' Skimr used to offer functions that combined skimming with a secondary effect,
#' like reshaping the data, building a list or printing the results. Some of
#' these behaviors are no longer necessary. [skim()] always returns a wide
#' data frame. Others have been replaced by functions that do a single thing.
#' [partition()] creates a list-like object from a skimmed data frame.
#'
#' @param .data A tibble, or an object that can be coerced into a tibble.
#' @param ...  Columns to select for skimming. When none are provided, the
#'   default is to skim all columns.
#' @return Either A `skim_df` or a `skim_list` object.
#' @name deprecated-v1
NULL

#' @describeIn deprecated-v1 [skim()] always produces a wide data frame.
#' @export
skim_to_wide <- function(.data, ...) {
  .Deprecated("skim()")
  skim(.data, ...)
}

#' @describeIn deprecated-v1 [partition()] creates a list.
#' @export
skim_to_list <- function(.data, ...) {
  .Deprecated("partition(skim())")
  skim(.data, ...) %>% partition()
}
