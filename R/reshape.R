#' Separate a big `skim_df` into smaller data frames, by type.
#'
#' The data frames produced by [skim()] are wide and sparse, filled with
#' columns that are mostly `NA`. For that reason, it can be convenient to
#' work with "by type" subsets of the original data frame. These smaller
#' subsets have their `NA` columns removed.
#'
#' `partition()` creates a list of smaller `skim_df` data frames. Each entry
#' in the list is a data type from the original `skim_df`. The inverse of
#' `partition()` is `bind()`, which takes the list and produces the original
#' `skim_df`. While `partition()` keeps all of the subtables as list entries,
#' `yank()` gives you a single subtable for a data type.
#'
#' @param data A `skim_df`.
#' @param type A character scalar. The subtable to extract from a `skim_df`.
#' @return A `skim_list` of `skim_df`'s, by type.
#' @examples
#' # Create a wide skimmed data frame (a skim_df)
#' skimmed <- skim(iris)
#'
#' # Separate into a list of subtables by type
#' separate <- partition(skimmed)
#'
#' # Put back together
#' identical(bind(separate), skimmed)
#' # > TRUE
#'
#' # Alternatively, get the subtable of a particular type
#' yank(skimmed, "factor")
#' @export
partition <- function(data) {
  stopifnot("type" %in% names(data))
  as_list <- split(data, data$type)
  types <- names(as_list)
  groups <- attr(data, "groups")
  skimmers <- reconcile_skimmers(data, groups)
  reduced <- purrr::imap(as_list, simplify_skimdf, skimmers, groups)
  rebuild_skim_obj(reduced, data, class = "skim_list", skimmers_used = skimmers)
}

#' Align the skimmers_used attribute with the current columns in the data
#'
#' This catches the case where users partition (or more likely print) a data
#' frame that has had columns added after skimming.
#' @noRd
reconcile_skimmers <- function(data, groups) {
  all_columns <- names(data)
  skimmers_used <- attr(data, "skimmers_used")
  with_base_columns <- c("type", "variable", purrr::flatten_chr(skimmers_used))
  extra_cols <- dplyr::setdiff(all_columns, with_base_columns)
  if (length(extra_cols) > 0) {
    grouped <- dplyr::group_by(data, !!rlang::sym("type"))
    complete_by_type <- dplyr::summarize_at(
      grouped,
      dplyr::vars(extra_cols),
      ~!all(is.na(.x))
    )

    complete_cols <- purrr::pmap(
      complete_by_type,
      get_complete_columns,
      names = extra_cols
    )
    new_cols_by_type <- purrr::set_names(complete_cols, complete_by_type$type)
    skimmers_used <- purrr::list_merge(skimmers_used, !!!new_cols_by_type)
  }
  skimmers_used
}

get_complete_columns <- function(type, ..., names) {
  return(names[c(...)])
}

#' For each type subtable, only select columns generated by this type's skimmers
#' This function also catches the case where the user removed columns from
#' the skim_df
#' @noRd
simplify_skimdf <- function(data, type, skimmers, groups) {
  keep <- c("variable", groups, skimmers[[type]])
  cols_in_data <- names(data)
  out <- dplyr::select(data, !!!dplyr::intersect(keep, cols_in_data))
  structure(
    out,
    class = c("one_skim_df", "tbl_df", "tbl", "data.frame"),
    type = type
  )
}

#' @describeIn partition The inverse of a `partition()`. Rebuild the original
#'   `skim_df`.
#' @export
bind <- function(data) {
  combined <- dplyr::bind_rows(!!!data, .id = "type")
  rebuild_skim_obj(combined, data)
}

#' @describeIn partition Extract a subtable from a `skim_df` with a particular
#'   type.
#' @export
yank <- function(data, type) {
  partition(data)[[type]]
}

#' Only show a subset of summary statistics after skimming
#'
#' This function is a variant of [dplyr::select()] designed to work with
#' `skim_df` objects. When using `focus()`, `skimr` metadata columns are kept,
#' and `skimr` print methods are still utilized. Otherwise, the signature and
#' behavior is identical to [dplyr::select()].
#'
#' @param .data A `skim_df` object.
#' @inheritParams dplyr::select
#' @examples
#' # Compare
#' iris %>%
#'   skim() %>%
#'   dplyr::select(missing)
#'
#' iris %>%
#'   skim() %>%
#'   focus(missing)
#'
#' # This is equivalent to
#' iris %>%
#'   skim() %>%
#'   dplyr::select(variable, type, missing)
#' @export
focus <- function(.data, ...) {
  stopifnot(inherits(.data, "skim_df"))
  dplyr::select(.data, "type", "variable", ...)
}

#' Skim results returned as a tidy long data frame with four columns:
#' variable, type, stat and formatted.
#' @param .data A tibble, or an object that can be coerced into a tibble.
#' @param ...  Columns to select for skimming. When none are provided, the
#'   default is to skim all columns.
#' @return A `skim_df` object, which also inherits the class(es) of the input
#'   data. The result is usually a data frame or tibble.
#' @examples
#' to_long(iris)
#' @export
to_long <- function( .data, ...){
  skimmed <- skim(.data, ...)
  tidyr::gather(skimmed, key="stat", value="formatted",  na.rm = TRUE,
                -!!rlang::sym("type"), -!!rlang::sym("variable")) }

#' Deprecated functions from skimr v1
#'
#' Skimr used to offer functions that combined skimming with a secondary effect,
#' like reshaping the data, building a list or printing the results. Some of
#' these behaviors are no longer necessary. [skim()] always returns a wide
#' data frame. Others have been replaced by functions that do a single thing.
#' [partition()] creates a list-like object from a skimmed data frame.
#'
#' @param .data A tibble, or an object that can be coerced into a tibble.
#' @param ...  Columns to select for skimming. When none are provided, the
#'   default is to skim all columns.
#' @return Either A `skim_df` or a `skim_list` object.
#' @name deprecated-v1
NULL

#' @describeIn deprecated-v1 [skim()] always produces a wide data frame.
#' @export
skim_to_wide<- function(.data, ...){
  .Deprecated("skim()")
  skim(.data, ...)
}

#' @describeIn deprecated-v1 [partition()] creates a list.
#' @export
skim_to_list<- function(.data, ...){
  .Deprecated("partition(skim())")
  skim(.data, ...) %>% partition()
}
